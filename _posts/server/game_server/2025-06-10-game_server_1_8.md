---
title:  "[게임 서버] 1.8 잠금 순서의 규칙"
excerpt: "1.8"

categories:
  - GameServer
tags:
  - [GameServer]

toc: true
toc_sticky: true
 
date: 2025-06-10
last_modified_at: 2025-06-10
---
이 글은 아래의 책을 자세히 정리한 후, 정리한 글을 GPT에게 요약을 요청하여 작성되었습니다.  
게임 서버 프로그래밍 교과서, 배현직 저자
{: .notice--warning}

# 📦 1. 멀티스레딩

## 👉🏻 8. 잠금 순서의 규칙

### ✅ 1. 규칙

뮤텍스 A, B, C가 있을 때,  
**잠금 순서**는 아래처럼 정해져 있다고 가정하자:

> A → B → C

<br>
이 경우, 교착 상태(Deadlock)를 피하려면 **다음 규칙**을 반드시 지켜야 한다:

1. **잠금 순서를 반드시 지켜야 한다**.  
2. **잠금 해제 순서는 상관 없다**.

---

### 🔍 예시로 보는 올바른/잘못된 잠금 순서

| 잠금 순서 | 결과 |
| --- | --- |
| A → B → C | ✅ OK |
| B → C | ✅ OK |
| A → C → B | ❌ 역행 (C → B) |
| B → A | ❌ 역행 (B → A) |

→ **잠금할 때는 반드시 정해진 방향대로 진행**해야 하고,  
→ 해제할 때는 순서가 중요하지 않다.

---

### ✅ 2. 재귀 뮤텍스

**재귀 뮤텍스**는 **같은 스레드에서 같은 뮤텍스를 여러 번 잠그는 것**이다.

```cpp
lock(M);     // 잠금 1번
lock(M);     // 잠금 2번 (재귀 잠금)
unlock(M);   // 잠금 1번 해제
unlock(M);   // 잠금 완전 해제
```

→ 같은 뮤텍스를 **같은 스레드에서 여러 번 잠그는 건 OK**  
→ 단, 이걸 허용하려면 해당 뮤텍스가 재귀적이어야 한다 (`recursive_mutex` 등)

---

### 🔄 재귀 뮤텍스와 잠금 순서

```cpp
lock(A);     // 최초 잠금
lock(B);     // 최초 잠금
lock(C);     // 최초 잠금
lock(B);     // 재귀 잠금 (문제 없음)
lock(A);     // 재귀 잠금 (문제 없음)
...
unlock(...); // 해제
```

**최초 잠금 순서(A → B → C)** 를 잘 지켰고, 이후 재귀적으로 잠근 순서는 상관없기 때문에  
→ 이 코드는 **문제 없다**.

<br>

```cpp
lock(A);     // 최초 잠금
lock(C);     // 최초 잠금
lock(B);     // ❌ 역행 발생 (C → B)
lock(C); 
...
```

**최초 잠금 순서가 역행했기 때문에**, 이 코드는 **교착 상태를 유발할 수 있다!**

이후 아무리 재귀적으로 잘 잠근다고 해도,**최초 잠금이 잘못되면 그건 이미 틀린 코드**다.

---

# 🧐 정리

1. **잠금 순서는 반드시 지켜야 한다**. 역행은 금지!
2. **해제 순서는 자유**. 해제할 때는 순서 상관없다.
3. **중요한 건 최초 잠금 순서**. 이후의 재귀 잠금은 순서와 무관하다.

→ 잠금 순서를 정하고, 팀 전체가 이 규칙을 반드시 따라야 **교착 상태를 방지**할 수 있다.