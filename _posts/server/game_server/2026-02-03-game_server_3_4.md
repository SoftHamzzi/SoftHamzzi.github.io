---
title:  "[게임 서버] 3.4 네트워크 연결받기 및 수신"
excerpt: "3.3"

categories:
  - GameServer
tags:
  - [GameServer]

toc: true
toc_sticky: true
 
date: 2026-02-03
last_modified_at: 2026-02-03
---
# 📦 3. 소켓 프로그래밍
## 👉🏻 항목 4: 네트워크 연결받기 및 수신

### 📥 수신 버퍼(Receive Buffer)

**기본 개념:**

- 소켓 각각은 **송신 버퍼**와 **수신 버퍼**를 가진다

---

### 📩 수신 버퍼(Receive Buffer)

**특징:**

**1. 데이터 구조:**

- 바이트 배열을 가진다

**2. 작동 방식:**

- FIFO(First In First Out) 형태로 작동한다
- **운영체제가 push()**, **사용자가 pop()** 한다

**3. 데이터 처리:**

- 네트워크로 들어온 데이터는 운영체제가 수신 버퍼에 자동으로 저장한다

**4. 블로킹 조건:**

- 수신 버퍼가 비어 있다면 `recv()`는 데이터가 들어올 때까지 **블로킹**
- 수신 버퍼가 꽉 차면, 운영체제는 더 이상 데이터를 받지 못한다 (흐름 제어 발생)

---

### 💻 서버 측 소켓 동작 예시

```cpp
main() {
	s = socket(TCP); // 1
	s.bind(5959); // 2
	s.listen(); // 3
	s2 = s.accept(); // 4
	print(getpeeraddr(s2)); // 5
	while(true) {
		r = s2.recv(); // 6
		if(r.length <= 0) // 7
			break;
		print(r);
	}
	s2.close(); // 8
}
```

---

### 🔍 코드 흐름 분석

**1. `socket(TCP)`**

- TCP 소켓 생성

**2. `bind(5959)`**

- 5959번 포트를 점유 시도
- 이미 사용 중이라면 실패

**3. `listen()`**

- 해당 소켓을 **리스닝 소켓**으로 변환
- 즉시 리턴된다 (블로킹 아님)

**4. `accept()`**

- **클라이언트가 접속할 때까지 블로킹**
- 연결이 성립되면,
    - 새로운 TCP 소켓 핸들 반환 (`s2`)
    - 이 소켓은 5959번이 아닌 **새로운 포트**를 사용
- 리스닝 소켓은 계속해서 연결을 받을 준비만 함

**5. `getpeeraddr(s2)`**

- 새로 연결된 상대(클라이언트)의 주소 확인

**6. `recv()`**

- 수신 버퍼에 데이터가 있다면 즉시 리턴
- 없다면, 데이터가 들어올 때까지 **블로킹**

**7. `r.length <= 0`**

- 0바이트 수신은 **상대가 연결을 종료했다는 의미**
- 수신 루프 종료

**8. `close()`**

- 연결 종료 및 소켓 닫기

---

# 🧐 정리

- 수신 버퍼는 **운영체제가 push**, 사용자가 `recv()`로 **pop** 한다
- 네트워크 데이터는 자동으로 수신 버퍼에 쌓인다
- 수신 버퍼가 비어있으면 `recv()`는 블로킹된다
- 수신 버퍼가 가득 차면, 운영체제는 더 이상 데이터를 받지 못한다
- `listen()`은 블로킹되지 않는다
- `accept()`는 연결이 올 때까지 블로킹된다
- `recv()`는 데이터가 올 때까지 블로킹된다
- 0바이트 수신은 연결 종료 신호다