---
title:  "[게임 서버] 1.4 스레드 정체"
excerpt: "1.4"

categories:
  - GameServer
tags:
  - [GameServer]

toc: true
toc_sticky: true
 
date: 2025-05-29
last_modified_at: 2025-05-29
---
이 글은 아래의 책을 자세히 정리한 후, 정리한 글을 GPT에게 요약을 요청하여 작성되었습니다.  
게임 서버 프로그래밍 교과서, 배현직 저자
{: .notice--warning}

# 📦 1. 멀티스레딩
## 👉🏻 4. 스레드 정체

### 📌 컨텍스트 스위치 (Context Switch)

> 각 스레드를 실행하다 말고 다른 스레드를 실행하는 과정

컨텍스트 스위치가 발생하면 **많은 연산**이 발생한다.

> 너무 많이 발생하면? → **과도한 연산**
> 너무 적게 발생하면? → **프레임이 끊기고 답답함**

그래서 가급적이면 **쾌적한 정도**로 조절해야 한다.

---

### 💡 어떻게 작동하냐면?

1. 실행 중이던 스레드의 상태(호출 스택 등)를 어딘가 저장
2. 과거에 실행하다 만 다른 스레드 중 하나를 고름
3. 그 스레드의 상태(호출 스택 등)를 복원
4. 그 스레드가 실행하던 지점으로 **강제 이동**하여 실행

---

### ⏱ 타임 슬라이스 (Time Slice)

> 컨텍스트 스위치가 발생하는 **시간 단위**

---

### 🧠 컨텍스트 스위치와 CPU, 스레드 관계

| 상황              | 컨텍스트 스위치  |
| --------------- | --------- |
| CPU 개수 ≥ 스레드 개수 | ❌ 발생하지 않음 |
| CPU 개수 < 스레드 개수 | ✅ 발생함     |

즉, **Runnable 상태의 스레드가 CPU보다 많으면 문제**가 생긴다.
하지만 **Waitable 상태의 스레드**는 문제가 되지 않는다.

→ 프로그램 스레드가 아무리 많아도
**실제로 돌아가려는(Runnable) 스레드 개수만 CPU보다 적으면 문제 없음**

---

### 🧨 문제는 언제 발생하냐?

프로그램이 어느 정도 실행된 후에 **컨텍스트 스위치가 발생하는 타이밍**이 중요하다.

C++ 코드 한 줄이라고 해서 **원자적**으로 실행되는 게 아니다.

---

### 🧬 예시

#### 🔤 C 언어 코드

```cpp
b = a * 2;
```

#### ⚙️ 실제 기계어로 컴파일되면?

```asm
1. ...
2. r1 = a
3. r2 = r1 * 2
4. b = r2
5. ...
```

→ 이 중간에 **컨텍스트 스위치가 발생할 수도 있음**

예를 들어, `r2 = r1 * 2`까지만 하고, 다른 스레드로 넘어갔다가
다시 돌아와서 `b = r2`가 실행되는 식

그러므로 **한 줄 코드도 완전한 연산 단위가 아니다**.

---

정리하자면,
멀티스레딩에서는 **컨텍스트 스위치의 타이밍과 빈도**가 성능과 안정성에 영향을 준다.

그래서 스레드를 많이 돌릴 땐,
*실제로 동시에 돌아가야 하는 스레드가 얼마나 되는지* 잘 고려해서 짜야 한다.
