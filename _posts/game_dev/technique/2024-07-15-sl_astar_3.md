---
title:  "[Sebastian Lague] A* Pathfinding (E03: algorithm implementation)"
excerpt: "A* Pathfinding #03"

categories:
  - Techniques
tags:
  - [UE5, Unity, Algorithm]

toc: true
toc_sticky: true
 
date: 2024-07-15
last_modified_at: 2024-07-15
---
ì´ í¬ìŠ¤íŒ…ì€ [Sebastian Lagueì˜ A* Pathfinding ì˜ìƒ](https://youtu.be/mZfyt03LDH4?si=Yav15xsjs5Bq3apB)ì„ ê¸°ë°˜ìœ¼ë¡œ ì§„í–‰ë©ë‹ˆë‹¤.  
ê¹ƒí—ˆë¸Œ ì£¼ì†Œ: [Sebistian Lague's Github](https://github.com/SebLague/Pathfinding/tree/master)
{: .notice--warning}

<iframe width="560" height="315" src="https://www.youtube.com/embed/mZfyt03LDH4?si=Yav15xsjs5Bq3apB" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
&nbsp;

# ğŸ“¦ êµ¬í˜„
![image](https://github.com/SoftHamzzi/comments/assets/67397908/62199f11-f217-4744-8706-9d23064a6eb5)

ì´ì „ pseudo ì½”ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ A* ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•  ê²ƒì´ë‹¤.  
ì°¸ê³ ë¡œ, ì €ë²ˆ ì½”ë“œë“¤ì— í¬ì¸í„°ë¥¼ ë¶™ì´ëŠ” ë“± ìˆ˜ì •ì‚¬í•­ì´ ë§ë‹¤.

# ğŸ“œ Pathfinding.h
```cpp
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Pathfinding.generated.h"

struct FNode;
class AGrid;

UCLASS()
class SL_ASTAR_API APathfinding : public AActor
{
	GENERATED_BODY()
	
public:	
	// Sets default values for this actor's properties
	APathfinding();

  // ë ˆë²¨ì— ìˆëŠ” Gridë¥¼ ì°¸ì¡°í•˜ê¸° ìœ„í•œ ë³€ìˆ˜.
  // Grid.hì˜ UCLASS ì•ˆì— BlueprintTypeì„ ë„£ì–´ì¤˜ì•¼ ì‘ë™í•¨.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pathfinding")
	AGrid* Grid;

  // ì‹œì‘ì 
	UPROPERTY(EditAnywhere)
	AActor* Seeker;

  // ë„ì°©ì 
	UPROPERTY(EditAnywhere)
	AActor* Target;

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

  // ê²½ë¡œ ì°¾ê¸°
	void FindPath(const FVector& StartPos, const FVector& TargetPos);

  // Hê°’(í˜„ì¬ ë…¸ë“œ - ë„ì°© ë…¸ë“œ) ê±°ë¦¬ êµ¬í•˜ëŠ” í•¨ìˆ˜
	int GetDistance(FNode* NodeA, FNode* NodeB);

  // FindPath í•¨ìˆ˜ê°€ ì‹¤í–‰ëœ í›„, ìµœì¢… ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” í•¨ìˆ˜
	void RetracePath(FNode* StartNode, FNode* EndNode);
};
```

ì—ë””í„° ìƒì—ì„œ Seekerì™€ Target ì—­í• ì„ í•´ì¤„ ì„ì˜ Actorë¥¼ ë§Œë“¤ê³ ,  
ë¸”ë£¨í”„ë¦°íŠ¸ ë³€ìˆ˜ì— ë„£ì–´ì£¼ë©´ ëœë‹¤.

# ğŸ“œ Pathfinding.cpp
## FindPath() íŒŒíŠ¸
```cpp
void APathfinding::FindPath(const FVector& StartPos, const FVector& TargetPos) {
	FNode* StartNode = Grid->NodeFromWorldPoint(StartPos);
	FNode* TargetNode = Grid->NodeFromWorldPoint(TargetPos);

	TArray<FNode*> OpenSet;
	TSet<FNode*> ClosedSet;
	OpenSet.Emplace(StartNode);

	while (OpenSet.Num() > 0) {
    // OpenSetì—ì„œ FCostê°€ ê°€ì¥ ì‘ìœ¼ë©´ì„œ, HCost ë˜í•œ ì‘ì€ ë…¸ë“œë¥¼ êµ¬í•¨.
		FNode* CurrentNode = OpenSet[0];
		for (int i = 0; i < OpenSet.Num(); i++) {
			if (
				OpenSet[i]->FCost() < CurrentNode->FCost() ||
				(OpenSet[i]->FCost() == CurrentNode->FCost() && OpenSet[i]->HCost < CurrentNode->HCost)
				) {
				CurrentNode = OpenSet[i];
			}
		}
		OpenSet.Remove(CurrentNode);
		ClosedSet.Emplace(CurrentNode);

    // ëª©ì ì§€ì— ë„ë‹¬í•œ ê²½ìš°
		if (CurrentNode == TargetNode) {
      // ìµœì¢… ê²½ë¡œ ì°¾ê¸°
			RetracePath(StartNode, TargetNode);
			return;
		}

    // í˜„ì¬ ë…¸ë“œì—ì„œ ëª¨ë“  ì´ì›ƒ ê²€ìƒ‰
		for (FNode* Neighbour : Grid->GetNeighbours(CurrentNode)) {
      // ì´ì›ƒ ë…¸ë“œê°€ ì¥ì• ë¬¼ì´ê±°ë‚˜, ClosedSetì— ì†í•œ ê²½ìš° continue
			if (!Neighbour->bWalkable || ClosedSet.Contains(Neighbour)) continue;

      // í•œë²ˆë„ ì—°ì‚°ëœì  ì—†ëŠ” ë…¸ë“œê±°ë‚˜, ì—°ì‚°ëì—ˆì§€ë§Œ ìƒˆë¡œìš´ ê²½ë¡œê°€ ë” ë¹ ë¥¸ ê²½ìš°
			int NewMovementCostToNeighbour = CurrentNode->GCost + GetDistance(CurrentNode, Neighbour);
			if (NewMovementCostToNeighbour < Neighbour->GCost || !OpenSet.Contains(Neighbour)) {
				Neighbour->GCost = NewMovementCostToNeighbour;
				Neighbour->HCost = GetDistance(Neighbour, TargetNode);
				Neighbour->Parent = CurrentNode;

        // ì—°ì‚°ëœì  ì—†ëŠ” ë…¸ë“œì˜€ë‹¤ë©´ OpenSetì— ì¶”ê°€
				if (!OpenSet.Contains(Neighbour)) OpenSet.Emplace(Neighbour);
			}
		}
	}
}
```

### ğŸ‘‰ğŸ» íŠ¹ì§•
1. Emplace()ì™€ Add()
- EmplaceëŠ” ì°¸ì¡° ë³€ìˆ˜ë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒì´ê³ , AddëŠ” ë³€ìˆ˜ë¥¼ ë³µì‚¬í•˜ì—¬ ì¶”ê°€í•˜ëŠ” ê²ƒìœ¼ë¡œ ë‹¤ë¥´ë‹¤.  
ìµœì í™”ë¥¼ ìœ„í•´ì„  ì•Œë§ì€ ê³³ì— Emplaceë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

2. í¬ì¸í„°
- ìœ ë‹ˆí‹°ì˜ í´ë˜ìŠ¤ëŠ” ì°¸ì¡° í˜•ì‹, êµ¬ì¡°ì²´ëŠ” ê°’ í˜•ì‹ì´ë‹¤.
- ì–¸ë¦¬ì–¼ì€ í´ë˜ìŠ¤ì™€ êµ¬ì¡°ì²´ ëª¨ë‘ ê°’ í˜•ì‹ìœ¼ë¡œ êµ¬í˜„ë˜ì–´ìˆë‹¤.
- Sebastian Lagueì€ ìœ ë‹ˆí‹°ë¥¼ ì“°ê³ , NodeëŠ” í´ë˜ìŠ¤ë¡œ êµ¬í˜„ë˜ì—ˆìœ¼ë¯€ë¡œ, ë³€ìˆ˜ê°€ ë³µì‚¬ë˜ëŠ” ì¼ì´ ì—†ì—ˆë‹¤.  
í•˜ì§€ë§Œ ì–¸ë¦¬ì–¼ì„ ì“°ëŠ” ìƒí™©ì—ì„œ Neighbourì™€ Parentê°€ ë˜‘ê°™ì€ ê°ì²´ë¥¼ ê°€ë¦¬í‚¤ê²Œ í•˜ê¸° ìœ„í•´ì„  í¬ì¸í„°ë¥¼ ì‚¬ìš©í•´ì•¼ í–ˆë‹¤.

## GetDistance() íŒŒíŠ¸
```cpp
// ë‘ ë…¸ë“œ ê°„ì˜ ê±°ë¦¬
int APathfinding::GetDistance(FNode* NodeA, FNode* NodeB) {

	int DstX = abs(NodeA->GridX - NodeB->GridX);
	int DstY = abs(NodeA->GridY - NodeB->GridY);

	if (DstX > DstY)
		return 14 * DstY + 10 * (DstX - DstY);
	return 14 * DstX + 10 * (DstY - DstX);
}
```

### ğŸ‘‰ğŸ» íŠ¹ì§•
1. ë§ë‹¿ì€ ê±°ë¦¬ëŠ” 10, ëŒ€ê°ì„  ê±°ë¦¬ëŠ” 14ë¡œ ì¹˜ê³  ê³„ì‚°í•˜ê³  ìˆë‹¤.

## RetracePath() íŒŒíŠ¸
```cpp
// ìµœì¢… ê²½ë¡œ íƒìƒ‰ í•¨ìˆ˜
void APathfinding::RetracePath(FNode* StartNode, FNode* EndNode) {
	
	Grid->Path.Empty();
	FNode* CurrentNode = EndNode;

	while (CurrentNode != StartNode) {
		Grid->Path.Emplace(CurrentNode);
		if (!CurrentNode->Parent) {
			UE_LOG(LogTemp, Warning, TEXT("Parent is nullptr"));
			return;
		}
		CurrentNode = CurrentNode->Parent;
	}
	Grid->Path.Emplace(StartNode);

	Algo::Reverse(Grid->Path);

}
```

### ğŸ‘‰ğŸ» íŠ¹ì§•
1. TList ëŒ€ì‹  TArray
- ìœ ë‹ˆí‹°ì—ëŠ” ë¦¬ìŠ¤íŠ¸ê°€ ì˜ êµ¬í˜„ë˜ì–´ ìˆì§€ë§Œ, ì–¸ë¦¬ì–¼ì—ëŠ” ë¦¬ìŠ¤íŠ¸ì˜ ê¸°ëŠ¥ì´ ê±°ì˜ ì—†ë‹¤ì‹œí”¼ í•˜ë‹¤.  
TListë³´ë‹¨ TArrayë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒì„ ì¶”ì²œí•˜ëŠ” ê²½ìš°ê°€ ë§ì•„, TArrayë¡œ êµ¬í˜„í•˜ì˜€ë‹¤.
2. Reverse í•¨ìˆ˜
- ì–¸ë¦¬ì–¼ì˜ TArrayì—ëŠ” Reverseê°€ ë‚´ì¥ë˜ì–´ ìˆì§€ ì•Šë‹¤.  
ê·¸ë ‡ê¸°ì— #include "Algo/Reverse.h"ë¥¼ í•´ì¤€ ë’¤, Algo::Reverse í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ í•´ì£¼ì—ˆë‹¤.

## Tick() íŒŒíŠ¸

```cpp
// Called every frame
void APathfinding::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	// Seeker&Target ê²€ì‚¬. ìœ íš¨ì„± ê²€ì‚¬ë¥¼ í•˜ì§€ ì•Šìœ¼ë©´ í¬ë˜ì‹œ ë‚˜ë¯€ë¡œ ì£¼ì˜.
	if (!Seeker || !Target) return;
  // ë§¤ í‹±ë§ˆë‹¤ Path ê²€ì‚¬
	FindPath(Seeker->GetActorLocation(), Target->GetActorLocation());

}
```

# ğŸ“œ Grid.h
```cpp
USTRUCT(Atomic)
struct FNode {
	GENERATED_USTRUCT_BODY()

public:
	bool bWalkable;
	FVector WorldPosition;

	FNode* Parent;

  // ê·¸ë¦¬ë“œ ë‚´ ë°°ì—´ ì¢Œí‘œ
	int GridX;
	int GridY;

	int GCost;
	int HCost;
	int FCost() { return GCost + HCost; }

	FNode() {
		bWalkable = true;
		WorldPosition = FVector(0, 0, 0);
		Parent = nullptr;

		GridX = 0;
		GridY = 0;
	}

	FNode(bool _walkable, FVector _worldPos, int _gridX, int _gridY) {
		bWalkable = _walkable;
		WorldPosition = _worldPos;

		GridX = _gridX;
		GridY = _gridY;
	}

	bool operator==(const FNode& Other) const {
		return WorldPosition == Other.WorldPosition;
	}
};

FORCEINLINE uint32 GetTypeHash(const FNode& Node) {
	return GetTypeHash(Node.WorldPosition);
}

// ë„£ì–´ì£¼ì–´ì•¼ ì—ë””í„° ìƒì—ì„œ í•´ë‹¹ í´ë˜ìŠ¤ë¥¼ ë‹¤ë¥¸ ë¸”ë£¨í”„ë¦°íŠ¸ ë³€ìˆ˜ì— ê°’ìœ¼ë¡œ ë„£ì–´ì¤„ìˆ˜ ìˆìŒ
UCLASS(BlueprintType)
class SL_ASTAR_API AGrid : public AActor
{
public:
  TArray<FNode*> Path; // ìµœì¢… ê²½ë¡œ
  // ...
}
```

### ğŸ‘‰ğŸ» íŠ¹ì§•
1. GetTypeHash()ì™€ ë“±ìœ„ ì—°ì‚°ì ì˜¤ë²„ë¡œë”©
- TSetë˜ëŠ” TMapì— ì»¤ìŠ¤í…€ êµ¬ì¡°ì²´(FNode)ë¥¼ ë„£ì–´ì£¼ê¸° ìœ„í•´ì„ ,  
ë“±ìœ„ ì—°ì‚°ì(operator==)ì™€ GetTypeHash()ë¥¼ ì¶”ê°€í•´ì£¼ì–´ì•¼ë§Œ í•œë‹¤.  
ì°¸ê³  : https://devjino.tistory.com/267

2. GridX, GridY, G, H, F ë³€ìˆ˜ ì¶”ê°€
- ìƒˆë¡œ ì¶”ê°€ëœ Pathfinding í´ë˜ìŠ¤ë¥¼ ìœ„í•´ ì„ ì–¸í•˜ì˜€ë‹¤.

3. UCLASS(BlueprintType)
- ì—ë””í„° ìƒì—ì„œ í•´ë‹¹ í´ë˜ìŠ¤ë¥¼ ë‹¤ë¥¸ ë¸”ë£¨í”„ë¦°íŠ¸ì— ë„£ì–´ì£¼ê¸° ìœ„í•¨

# ğŸƒğŸ» ì‹¤í–‰

![image](https://github.com/user-attachments/assets/c25005b2-ee9c-4148-9c32-d95d95779b3f)

ì˜¬ë°”ë¥´ê²Œ ê²½ë¡œê°€ ë‚˜íƒ€ë‚˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

# ğŸª¶ ê¹ƒí—ˆë¸Œ

[![Readme Card](https://github-readme-stats.vercel.app/api/pin/?username=SebLague&amp;repo=Pathfinding)](https://github.com/SebLague/Pathfinding/tree/master)  
Sebastian Lague - Unity  
[![Readme Card](https://github-readme-stats.vercel.app/api/pin/?username=SoftHamzzi&amp;repo=Pathfinding-UE5)](https://github.com/SoftHamzzi/Pathfinding-UE5)  
Me - UE5