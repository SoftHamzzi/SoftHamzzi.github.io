---
title:  "[C++] 항목 53: 컴파일러 경고를 지나치지 말자"
excerpt: "항목 53"

categories:
  - Cpp
tags:
  - [Cpp]

toc: true
toc_sticky: true
 
date: 2025-11-11
last_modified_at: 2025-11-11
---
이 글은 아래의 책을 자세히 정리한 후, 정리한 글을 GPT에게 요약을 요청하여 작성되었습니다.  
이펙티브 C++ 제3판, 스콧 마이어스 저자, 곽용재 번역
{: .notice--warning}

# 📦 9. 그 밖의 이야기들
## 👉🏻 항목 53: 컴파일러 경고를 지나치지 말자

### ⚠️ 컴파일러 경고의 중요성

**예제 코드:**

```cpp
class B {
public:
	virtual void f() const;
};

class D: public B {
public:
	virtual void f();
};
```

**의도:**

- 가상 함수 `B::f`를 `D::f`에서 오버라이드하겠다는 의도였다

**문제점:**

- `B::f`에는 `const`를 붙였고, `D::f`는 붙이지 않았다
    - `B::f`는 상수 함수, `D::f`는 비상수 함수가 된다
    - 두 함수의 시그니처가 다른 상황이다

---

### 🔍 경고 메시지 분석

```cpp
warning: D::f() hides virtual B::f()
```

**경고 메시지 의미:**

- 실행하면 "D::f가 B::f를 가린다"는 경고 메시지가 뜬다

**🚨 주의점:**

- **오버라이드됐다는 뜻이 아니다!**
- 이것은 `B::f`의 함수가 가려졌다고 경고하는 것이다!

---

### 🎭 이름 가려짐 문제

```cpp
class B {
public:
	void f(int x) {
	  cout << "Base::f(int): " << x << endl;
  }
};

class D : public B {
public:
	void f(double x) {
		cout << "Derived::f(double): " << x << endl;
	}
};

int main() {
	D d;
	// D::f(double) 호출
	d.f(3.14);
	// ⚠️ B::f(int)가 아닌, D::f(double)이 변환 호출됨!
	d.f(10);
}
```

**문제 분석:**

- 함수의 시그니처가 다르기에, 함수의 이름이 가려지는 문제가 발생한다
- 만약 `D`에서 `B::f(int)`를 사용하길 원했다면, `D`에 아래의 코드를 추가했어야 했다
    - `using B::f; // Base의 f들을 다시 노출시킴`

---

# 🧐 정리

- 컴파일러 경고를 쉽게 지나치지 말자
- 컴파일러에서 지원하는 최고 경고 수준에도 경고 메시지를 내지 않고 컴파일되는 코드를 만들도록 하자
- 그렇다고 컴파일러의 경고에 너무 기대지 말자
    - 컴파일러마다 경고를 내는 부분이 달라 당황할 수 있다