---
title:  "프로그래머스: 입국심사⭐⭐⭐"
excerpt: "이분탐색을 이용한 풀이"

categories:
  - Programmers
tags:
  - [Blog, Programmers, Algorithm, C++]

toc: true
toc_sticky: true
 
date: 2025-11-18
last_modified_at: 2025-11-18
---
> 체감 난이도 : ⭐⭐⭐  
> 유형 : 이분 탐색  
> 걸린 시간: 1시간  

# 🧐 문제
## 문제 설명

n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.

처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.

모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

## 제한사항

- 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
- 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
- 심사관은 1명 이상 100,000명 이하입니다.

## 입출력 예

|n|times|return|
|---|---|---|
|6|[7, 10]|28|

### 입출력 예 설명

가장 첫 두 사람은 바로 심사를 받으러 갑니다.

7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.

10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.

14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.

20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.

---

# ✏️ 풀이 과정

현재 지난 시간을 `T`, 심사받은 수를 `CNT`라고 하겠다.  
예제에 있던 대로 times = [7, 10]으로 진행한다.

|T|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|**CNT**|0|0|0|0|0|0|0|**1**|1|1|**2**|2|2|2|**3**|3|
|**T**|**16**|**17**|**18**|**19**|**20**|**21**|**22**|**23**|**24**|**25**|**26**|**27**|**28**|**29**|**30**|**31**|
|**CNT**|3|3|3|3|**4**|**5**|5|5|5|5|5|5|**6**|6|**7**|7|

각 시간별로, 심사가 끝나는 시간을 계산해보았다.

이 표를 보면 보자말자 느껴지는 것이 있다.  
`CNT += T/times[i]`를 해주면 심사받은 수가 나오는구나!

이제 문제의 조건을 만족하는 가장 작은 T를,  
이분탐색을 사용하여 구하면 된다.

---

# ✏️ 나의 풀이

{% raw %}
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

ll calc(vector<int>& times, ll t) {
    ll cnt = 0;
    for(int time : times)
        cnt += t/time;
    
    return cnt;
}

ll divide(int& n, vector<int>& times, ll left, ll right) {
    ll mid = (left + right) / 2;
    if(left > right) return mid+1;
    
    ll result = calc(times,mid);
    if(n <= result) return divide(n, times, left, mid-1);
    else return divide(n, times, mid+1, right);
    
}

ll solution(int n, vector<int> times) {
    ll max = *max_element(times.begin(), times.end());
    return divide(n, times, 0, max * n);
}
```
{% endraw %}

- 이 문제의 조건에 맞게, 이분탐색을 구현하는 포인트는 두가지다.
    1. `if(left > right) return mid+1;`
        - 종료 조건이다.
        - 2번에서 구한 T-1에 1을 더하여, 정답을 구한다.
    2. `if(n <= result) ...`
        - 최대한 작은 T를 구할 수 있도록 하는데,
        - T-1의 위치에 멈춘다.

---

# ✔️ 정진호님의 풀이

{% raw %}
```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

long long solution(int n, vector<int> times) {
    sort(times.begin(), times.end());

    long long left = (long long)times[0];
    long long right = (long long)times[times.size() - 1] * n;
    long long answer = right;
    while(left <= right){
        long long mid = (right + left) / 2;
        long long pass = 0;

        for(int i = 0; i < times.size(); ++i)
            pass += mid / (long long)times[i];

        if(pass >= n){
            right = mid - 1;
            if(mid <= answer)
                answer = mid;
        }
        else 
            left = mid + 1;
    }
    return answer;
}

```
{% endraw %}

## 🧐 분석

- 재귀대신 while을 사용하였을 뿐, 나의 코드와 다른 점은 없다.

---

# 🪶 후기

int를 사용할 수 있는 곳은 int를 쓰려다,  
오답이 나와서, 바보같이 시간을 많이 썼다. 