---
title:  "프로그래머스: 파괴되지 않은 건물⭐⭐⭐(실패)"
excerpt: "누적 합을 이용한 풀이"

categories:
  - Programmers
tags:
  - [Blog, Programmers, Algorithm, C++]

toc: true
toc_sticky: true
 
date: 2026-01-09
last_modified_at: 2026-01-09
---
> 체감 난이도 : ⭐⭐⭐⭐  
> 걸린 시간: 1시간 초과!  

# 🧐 문제
## 문제 설명

**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**

N x M 크기의 행렬 모양의 게임 맵이 있습니다. 이 맵에는 내구도를 가진 건물이 각 칸마다 하나씩 있습니다. 적은 이 건물들을 공격하여 파괴하려고 합니다. 건물은 적의 공격을 받으면 내구도가 감소하고 내구도가 0이하가 되면 파괴됩니다. 반대로, 아군은 회복 스킬을 사용하여 건물들의 내구도를 높이려고 합니다.

적의 공격과 아군의 회복 스킬은 항상 직사각형 모양입니다.  
예를 들어, 아래 사진은 크기가 4 x 5인 맵에 내구도가 5인 건물들이 있는 상태입니다.

![04_2022_공채문제_파괴되지않은건물_01.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/9932445f-244d-4188-a559-f16044cfa4d3/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_01.png)

첫 번째로 적이 맵의 **(0,0)부터 (3,4)까지 공격하여 4만큼** 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.

![04_2022_공채문제_파괴되지않은건물_02.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/2a3df058-d7b6-4317-9352-8f9713a9424a/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_02.png)

두 번째로 적이 맵의 **(2,0)부터 (2,3)까지 공격하여 2만큼** 건물의 내구도를 낮추면 아래와 같이 4개의 건물이 파괴되는 상태가 됩니다.

![04_2022_공채문제_파괴되지않은건물_03.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/94a07a93-71e3-447c-83cf-f855176e28c1/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_03.png)

세 번째로 아군이 맵의 **(1,0)부터 (3,1)까지 회복하여 2만큼** 건물의 내구도를 높이면 아래와 같이 **2개의 건물이 파괴되었다가 복구**되고 2개의 건물만 파괴되어있는 상태가 됩니다.

![04_2022_공채문제_파괴되지않은건물_04.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/145dfcf7-02aa-44fd-b01b-ff56fb5b0dad/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_04.png)

마지막으로 적이 맵의 **(0,1)부터 (3,3)까지 공격하여 1만큼** 건물의 내구도를 낮추면 아래와 같이 8개의 건물이 더 파괴되어 총 10개의 건물이 파괴된 상태가 됩니다. **(내구도가 0 이하가 된 이미 파괴된 건물도, 공격을 받으면 계속해서 내구도가 하락하는 것에 유의해주세요.)**

![04_2022_공채문제_파괴되지않은건물_05.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/9ce05af0-e5b9-483a-aeb4-d7c0624c2dfb/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_05.png)

최종적으로 총 10개의 건물이 파괴되지 않았습니다.

건물의 내구도를 나타내는 2차원 정수 배열 `board`와 적의 공격 혹은 아군의 회복 스킬을 나타내는 2차원 정수 배열 `skill`이 매개변수로 주어집니다. 적의 공격 혹은 아군의 회복 스킬이 모두 끝난 뒤 파괴되지 않은 건물의 개수를 return하는 solution함수를 완성해 주세요.

---

## 제한사항

- 1 ≤ `board`의 행의 길이 (= `N`) ≤ 1,000
- 1 ≤ `board`의 열의 길이 (= `M`) ≤ 1,000
- 1 ≤ `board`의 원소 (각 건물의 내구도) ≤ 1,000
- 1 ≤ `skill`의 행의 길이 ≤ 250,000
- `skill`의 열의 길이 = 6
- `skill`의 각 행은 `[type, r1, c1, r2, c2, degree]`형태를 가지고 있습니다.
    - type은 1 혹은 2입니다.
        - type이 1일 경우는 적의 공격을 의미합니다. 건물의 내구도를 낮춥니다.
        - type이 2일 경우는 아군의 회복 스킬을 의미합니다. 건물의 내구도를 높입니다.
    - (r1, c1)부터 (r2, c2)까지 직사각형 모양의 범위 안에 있는 건물의 내구도를 degree 만큼 낮추거나 높인다는 뜻입니다.
        - 0 ≤ r1 ≤ r2 < `board`의 행의 길이
        - 0 ≤ c1 ≤ c2 < `board`의 열의 길이
        - 1 ≤ degree ≤ 500
        - type이 1이면 degree만큼 건물의 내구도를 낮춥니다.
        - type이 2이면 degree만큼 건물의 내구도를 높입니다.
- 건물은 파괴되었다가 회복 스킬을 받아 내구도가 1이상이 되면 파괴되지 않은 상태가 됩니다. 즉, 최종적으로 건물의 내구도가 1이상이면 파괴되지 않은 건물입니다.

## 정확성 테스트 케이스 제한 사항

- 1 ≤ `board`의 행의 길이 (= `N`) ≤ 100
- 1 ≤ `board`의 열의 길이 (= `M`) ≤ 100
- 1 ≤ `board`의 원소 (각 건물의 내구도) ≤ 100
- 1 ≤ `skill`의 행의 길이 ≤ 100
    - 1 ≤ degree ≤ 100

## 효율성 테스트 케이스 제한 사항

- 주어진 조건 외 추가 제한사항 없습니다.

---

## 입출력 예

|board|skill|result|
|---|---|---|
|\[[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5]]|\[[1,0,0,3,4,4],[1,2,0,2,3,2],[2,1,0,3,1,2],[1,0,1,3,3,1]]|10|
|\[[1,2,3],[4,5,6],[7,8,9]]|\[[1,1,1,2,2,4],[1,0,0,1,1,2],[2,2,0,2,0,100]]|6|

---

### 입출력 예 설명

<details>
<summary>접기/펼치기</summary>

<p><strong>입출력 예 #1</strong></p>
<p>문제 예시와 같습니다.</p>

<p><strong>입출력 예 #2</strong></p>

<p>&lt;초기 맵 상태&gt;</p>

<p>
  <img
    src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/aa43439f-3d2f-4307-97ce-5910105b4487/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_06.png"
    alt="초기 맵 상태"
  />
</p>

<p>
  첫 번째로 적이 맵의 <strong>(1,1)부터 (2,2)까지 공격하여 4만큼</strong> 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.
</p>

<p>
  <img
    src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/aa361925-45e4-4bd0-9ef7-e182ed1c6f03/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_07.png"
    alt="첫 번째 공격 후 상태"
  />
</p>

<p>
  두 번째로 적이 맵의 <strong>(0,0)부터 (1,1)까지 공격하여 2만큼</strong> 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.
</p>

<p>
  <img
    src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/43c218a1-73c4-4d54-9568-0c21aa7f6365/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_08.png"
    alt="두 번째 공격 후 상태"
  />
</p>

<p>
  마지막으로 아군이 맵의 <strong>(2,0)부터 (2,0)까지 회복하여 100만큼</strong> 건물의 내구도를 높이면 아래와 같은 상황이 됩니다.
</p>

<p>
  <img
    src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/5190fee3-8e81-45b7-a79c-1dfc31d8e05f/04_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%91%E1%85%A1%E1%84%80%E1%85%AC%E1%84%83%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A1%E1%86%AD%E1%84%8B%E1%85%B3%E1%86%AB%E1%84%80%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AF_09.png"
    alt="회복 후 최종 상태"
  />
</p>

<p>
  총, 6개의 건물이 파괴되지 않았습니다. 따라서 6을 return 해야 합니다.
</p>

</details>

---

##### 제한시간 안내

- 정확성 테스트 : 10초
- 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수

---

# ✏️ 풀이

{% raw %}
```cpp
#include <bits/stdc++.h>

using namespace std;

vector<vector<int>> v(1002, vector<int>(1002, 0));
int w, h;

void v_init(vector<vector<int>>& skills) {
    for(vector<int> skill : skills) {
        int type = skill[0];
        int r1 = skill[1], c1 = skill[2];
        int r2 = skill[3], c2 = skill[4];
        int degree = skill[5];
        
        v[r1][c1] += type == 1 ? -degree : degree;
        v[r1][c2+1] += type == 1 ? degree : -degree;
        v[r2+1][c1] += type == 1 ? degree : -degree;
        v[r2+1][c2+1] += type == 1 ? -degree : degree;
    }
}

void v_accSum() {
    for(int i=0; i<h; i++)
        for(int j=0; j<w; j++)
            v[i][j+1] += v[i][j];
    
    for(int i=0; i<h; i++)
        for(int j=0; j<w; j++)
            v[i+1][j] += v[i][j];
}

int getResult(vector<vector<int>>& board) {
    int result = 0;
    for(int i=0; i<h; i++)
        for(int j=0; j<w; j++)
            if(board[i][j] + v[i][j] > 0) result++;
    return result;
}

int solution(vector<vector<int>> board, vector<vector<int>> skill) {
    h = board.size(), w = board[0].size();
    v_init(skill);
    v_accSum();
    
    return getResult(board);
}
```
{% endraw %}

- [여기](https://yabmoons.tistory.com/728)를 참고했다.

만약 그냥 간단히 순회하며 풀었다면 어떻게 되었을까?

## 🌋 최악의 경우

- `board` 행&열 길이 = 1,000
- `r1, r2` = 1,000
- `skill` 행 길이 = 250,000
- 1,000 * 1,000 * 250,000 = 250,000,000,000

<br>

+ skill을 사용할 때마다, 결과 값을 저장하려고 시도한다.
+ 시간복잡도가 /[O(N^2)/]인데다, 1초에 수행하는 연산 횟수는 대개 1억번 내외이다.
+ 즉, 2500억 연산 횟수는 시간 내에 풀어내기엔 터무니없다.

## 🧹 최적화

현재 가장 큰 문제는 25만이라는 길이를 가진, skill 벡터이다.

반복 계산을 줄이기 위해선, 누적 합이라는 개념을 알고 있어야 한다.

> **누적 합:** 이전까지의 합을 미리 저장해두어, 구간 합을 빠르게 계산하는 기법

|A|0|2|2|0|0|
|:-:|:-:|:-:|:-:|:-:|:-:|
|**B**|**-3**|**-3**|**0**|**0**|**0**|

예를 들어 위와 같은 스킬이 들어왔다면 각각 아래와 같이 표현할 수 있다.

|A|0|2|0|-2|0|
|:-:|:-:|:-:|:-:|:-:|:-:|
|**B**|**-3**|**0**|**3**|**0**|**0**|

위를 누적 합을 통해 복호화해보면, 이전과 같은 값이 나온다.

|암호화|-3|2|3|-2|0|
|:-:|:-:|:-:|:-:|:-:|:-:|
|**복호화**|**-3**|**-1**|**2**|**0**|**0**|

암호화된 값들을 합하면 복호화했을 때, 합쳐진 상태로 나온다.

|2|0|-2|0|
|:-:|:-:|:-:|:-:|
|**0**|**0**|**0**|**0**|
|**-2**|**0**|**2**|**0**|
|**0**|**0**|**0**|**0**|

2차원 벡터에서도 동일하게 사용할 수 있다.



**행→열** 혹은 **열→행** 순서로 누적 합을 계산하면 복호화할 수 있다.

## 📠 계산

복호화된 2차원 스킬 벡터와 기존 테이블을 더하면,  
**최종 테이블 상태**를 얻어낼 수 있다.

---

# 🪶 후기

이 문제는 DP라고 볼 수 있을것 같다.

나는 이 문제를 보고 누적 합 방식을 떠올리기에는 너무나 많은 시간이 걸렸다..