---
title:  "[C++] 항목 19: 클래스 설계는 타입 설계와 똑같이 취급하자"
excerpt: "항목 19"

categories:
  - Cpp
tags:
  - [Cpp]

toc: true
toc_sticky: true
 
date: 2025-06-17
last_modified_at: 2025-06-17
---
이 글은 아래의 책을 자세히 정리한 후, 정리한 글을 GPT에게 요약을 요청하여 작성되었습니다.  
이펙티브 C++ 제3판, 스콧 마이어스 저자, 곽용재 번역
{: .notice--warning}

# 📦 4. 설계 및 선언
## 👉🏻 항목 19: 클래스 설계는 타입 설계와 똑같이 취급하자

### ✅ 클래스를 설계할 때 고려해야할 점들

- 새로 정의한 타입의 객체 생성 및 소멸은 어떻게 이루어져야 하는가?  
→ 이 부분이 어떻게 되는가에 따라 클래스의 생성자/소멸자 구현이 달라진다.

<br>

- 객체 초기화는 객체 대입과 어떻게 달라야 하는가?  
→ 초기화와 대입을 헷갈리지 않는 것이 중요하며, 각각에 해당되는 함수 호출이 다르다.

<br>

- 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가?  
→ <b>‘값에 의해 전달(Call-by-value)’</b>을 구현하는 것은 복사 생성자다.  
→ 주로 객체를 함수의 인자에 들어갈 때 ‘값에 의해 전달'이 사용된다.

<br>

- 새로운 타입이 가질 수 있는 적법한 값에 대한 제약은 무엇으로 잡을 것인가?  
→ <b>클래스의 불변속성(invariant)</b>: 클래스 데이터 멤버의 몇 가지 조합 값은 반드시 유효해야 한다.  
(e.g. Date 클래스에서 Year, Month, Day 변수의 값이 예상 외의 값인 경우)  
→ 불변속성은 생성자, 대입 연산자, 쓰기(setter) 함수, 예외 지정에 영향을 준다.

<br>

- 기존의 클래스 상속 계통망(inheritance graph)에 맞출 것인가?  
→ 클래스 B를 클래스 A에 상속시킨다.  
→ 설계가 클래스 A에 제약을 받는다. (e.g. 멤버 함수의 가상 함수 여부)

<br>

- 어떤 종류의 타입 변환을 허용할 것인가?  
→ 암시적(e.g. `operator T` 등의 방법으로 구현)  
→ 명시적(e.g. `.get()` 과 같은 전환 함수를 만든다.)

<br>

- 어떤 연산자와 함수를 두어야 의미가 있을까?

<br>

- 표준 함수들 중 어떤 것을 허용하지 말 것인가?  
→ private로 선언하여 막을 수 있다.

<br>

- 새로운 타입의 멤버 대한 접근 권한을 어느 쪽에 줄 것인가?  
→ 클래스 멤버를 public, protected, private 중 어디에 두지?  
→ friend를 넣어줄까?  
→ 상속된 데이터 멤버를 어떻게 관리하지?

<br>

- ‘선언되지 않은 인터페이스’로 무엇을 둘 것인가?  
→ 만들 클래스가 보장하는 것(성능, 예외 안전성, 자원 사용)은 클래스 구현에 제약으로 작동한다.

<br>

- 새로 만드는 타입이 얼마나 일반적인가?  
→ template를 넣어야 할까?

<br>

- 정말로 꼭 필요한 타입인가?  
→ 파생 클래스가 꼭 필요한가? 비멤버 함수나 템플릿 몇개로 해결되지 않을까?

<br>

---

클래스 설계는 타입 설계다.

새로운 타입을 정의하기 전에, 이들을 꼭 점검해보도록 하자.