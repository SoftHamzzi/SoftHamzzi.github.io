---
title:  "[C++] 항목 2: C++를 언어들의 연합체로 바라보는 안목은 필수"
excerpt: "항목 2"

categories:
  - cpp
tags:
  - [cpp]

toc: true
toc_sticky: true
 
date: 2025-01-02
last_modified_at: 2025-01-02
---
# 📦 1. C++에 왔으면 C++의 법을 따릅시다
## 👉🏻 항목 2: \#define 을 쓰려거든 const, enum, inline을 떠올리자

```cpp
#define ASPECT_RATIO 1.635 // 매크로
const double AspectRatio = 1.635; // 상수
```

위 코드는 매크로, 아래 코드는 상수이다.
웬만해선 상수를 사용하는 것을 추천한다.

### ⚠️ 문제점
**1. 유지 보수**

소스 코드가 컴파일러에게 넘어가기 전에 선행 처리자가 밀어버리고 숫자 상수로 바꾸어버리기 때문에 유지 보수에 문제가 생길 수 있다.

이는 에러가 발생하게 될 때, ASPECT_RATIO가 아닌, 1.635로 나타나게 된다.

**2. 사본 생성**

상수는 여러번 쓰이더라도 사본이 하나지만, 매크로는 등장 횟수만큼 사본이 생긴다.

그러므로, 컴파일을 거친 최종 코드의 크기가 상수를 썼을 때보다 크게 나올 수 있다.

### ⚠️ 주의점
**1. 상수 포인터를 정의하는 경우**

```cpp
const char * const authorName = "Scott Meyers";
```

'포인터'와 '포인터가 가리키는 대상'까지 const를 선언하려 한다면, 위와 같이 두 번 써주어야 한다.

```cpp
const std::string authorName("Scott Meyers");
```

현재는 'char *'을 사용하는 것보다, string 객체를 사용하는 것을 권장한다는 것을 알아두자.

**2. 클래스 상수를 정의하는 경우**

```cpp
class GamePlayer {
  private:
  static const int NumTurns = 5;
  int scores[NumTurns];
};
```
  
상수의 사본 개수가 한 개를 넘기지 못하도록 하려면 정적 멤버로 선언해주어야 한다.

그러나 위의 NumTurns는 선언된 것이지, 정의된 것이 아니다.
컴파일 타임에 상수로 올라간 것이 아니기 때문이다.

정의를 하기 위해선 아래와 같이 코드를 짜주어야 한다.

```cpp
// 헤더 파일
class GamePlayer {
  private:
  static const int NumTurns;
  int scores[NumTurns];
};

// 구현 파일
const int GamePlayer::NumTurns = 5;
```



3. 