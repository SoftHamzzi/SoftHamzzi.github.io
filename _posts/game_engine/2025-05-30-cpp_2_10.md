---
title:  "[C++] 항목 10: 대입 연산자는 *this의 참조자를 반환하게 하자"
excerpt: "항목 10"

categories:
  - Cpp
tags:
  - [Cpp]

toc: true
toc_sticky: true
 
date: 2025-05-30
last_modified_at: 2025-05-30
---
이 글은 아래의 책을 자세히 정리한 후, 정리한 글을 GPT에게 요약을 요청하여 작성되었습니다.  
이펙티브 C++ 제3판, 스콧 마이어스 저자, 곽용재 번역
{: .notice--warning}

# 📦 2. 생성자, 소멸자 및 대입 연산자

## 👉🏻 항목 10: 대입 연산자는 \*this의 참조자를 반환하게 하자

```cpp
int x, y, z;
x = y = z = 15; // 대입이 사슬처럼 이어진다.
x = (y = (z = 15)); // 위 코드의 분석. 같은 의미이다.
```
→ 이건 C++에서 **우측 연관 연산**이란 특징 덕분에 가능한 것이다.  
<br>
즉,
```
z = 15 → y → x
```

이런 순서로 **연쇄적으로 대입**이 일어난다.
<br>

이게 가능한 이유는, **대입 연산자가 좌변 인자에 대한 참조자**를 반환하도록 구현되어 있기 때문이다.

> 이건 C++에서의 **관례**다.

---

### 예시 코드

```cpp
class Widget {
public:
	...
	// 반환 타입은 현재 클래스에 대한 참조자
	Widget& operator=(const Widget& rhs) {
		...
		return *this; // 좌변 객체(의 참조자)를 반환
	}
	...
};
```

이처럼 `operator=`는 항상 **자기 자신을 참조자로 반환**해야 한다.

이렇게 하면 `a = b = c;` 같은 연쇄 대입이 가능해진다.

---

### 📌 이 규약은 다른 연산자에도 동일하게 적용됨

```cpp
class Widget {
public:
	...
	// +=, -=, *= 등에도 동일한 규약 적용
	Widget& operator+=(const Widget& rhs) {
		...
		return *this;
	}
	
	// 대입 연산자의 매개변수 타입이
	// 일반적이지 않더라도, 동일한 규약 적용
	Widget& operator=(int rhs) {
		...
		return *this;
	}
};
```

즉, **매개변수 타입이 뭐든 상관없이**,
또는 **+=, -= 같은 복합 대입 연산자에서도**,
항상 **`*this`의 참조자를 반환해야 한다.**

---

# 🧐 정리

1. **대입 연산자는 항상 `*this`의 참조자를 반환하도록 한다.**
2. 이건 C++에서 대입 연산을 **연쇄적으로 처리**하기 위한 중요한 규약이다.
3. 단순 대입뿐 아니라, `+=`, `-=`, `= int` 같은 경우에도 **모두 동일하게 적용**해야 한다.

→ **안전하고 직관적인 대입 연산자 구현을 위한 필수 원칙**이다.