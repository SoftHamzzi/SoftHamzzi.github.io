---
title:  "[Sebastian Lague] A* Pathfinding (E02: node grid) Part 2"
excerpt: "A* Pathfinding #02 - 2"

categories:
  - Techniques
tags:
  - [UE5, Unity, Algorithm]

toc: true
toc_sticky: true
 
date: 2024-07-12
last_modified_at: 2024-07-12
---
ì´ í¬ìŠ¤íŒ…ì€ [Sebastian Lagueì˜ A* Pathfinding ì˜ìƒ](https://youtu.be/nhiFx28e7JY?si=81JsxqYwW6M3Jd1n)ì„ ê¸°ë°˜ìœ¼ë¡œ ì§„í–‰ë©ë‹ˆë‹¤.  
ê¹ƒí—ˆë¸Œ ì£¼ì†Œ: [Sebistian Lague's Github](https://github.com/SebLague/Pathfinding/blob/master/Episode%2002%20-%20grid/Assets/Grid.cs)
{: .notice--warning}

<iframe width="560" height="315" src="https://www.youtube.com/embed/nhiFx28e7JY?si=81JsxqYwW6M3Jd1n" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
&nbsp;

# ğŸ§ êµ¬í˜„
ì—¬ê¸°ì„œë¶€í„´ ê¸°ì¡´ì— ìˆë˜ Grid í´ë˜ìŠ¤ë¥¼ ì§œì„œ êµ¬í˜„í•´ì•¼ í•œë‹¤.

## ğŸ“œ êµ¬ì¡° ë° ë³€ìˆ˜ ì„ ì–¸
```cs
public class Grid : MonoBehaviour {

	public LayerMask unwalkableMask;
	public Vector2 gridWorldSize;
	public float nodeRadius;
	Node[,] grid;

	float nodeDiameter;
	int gridSizeX, gridSizeY;
  // ...
}

public class Node {
	
	public bool walkable;
	public Vector3 worldPosition;
	
	public Node(bool _walkable, Vector3 _worldPos) {
		walkable = _walkable;
		worldPosition = _worldPos;
	}
}
```

```cpp
USTRUCT(Atomic)
struct FNode {
	GENERATED_USTRUCT_BODY()

public:
	bool bWalkable;
	FVector worldPosition;

	FNode() {
		bWalkable = true;
		worldPosition = FVector(0, 0, 0);
	}

	FNode(bool _walkable, FVector _worldPos) {
		bWalkable = _walkable;
		worldPosition = _worldPos;
	}

	bool operator==(const FNode& other) const {
		return worldPosition == other.worldPosition;
	}
};

USTRUCT()
struct FGridRow {
	GENERATED_USTRUCT_BODY()
	TArray<FNode> Nodes;
};

private:
	UPROPERTY(EditAnywhere)
	float nodeRadius = 100.0f;
	UPROPERTY()
	TArray<FGridRow> grid;

	UPROPERTY()
	int gridSizeX = 10;
	UPROPERTY()
	int gridSizeY = 10;
	UPROPERTY()
	float nodeDiameter;
	UPROPERTY()
	float gridWorldSizeX;
	UPROPERTY()
	float gridWorldSizeY;
```

ë‘ ì½”ë“œì—ì„œ ë‹¤ë¥¸ ì ì´ë¼ê³  í•˜ë©´, Gridë¥¼ ì„ ì–¸í•´ì¤„ ë•Œë‹¤.  
ì–¸ë¦¬ì–¼ì—”ì§„ì˜ TArray ì•ˆì— TArrayë¥¼ ë„£ì–´ì¤„ ìˆ˜ ì—†ê¸°ì—, TGridRow êµ¬ì¡°ì²´ë¥¼ ì„ ì–¸í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•˜ì˜€ë‹¤.

## Start() / BeginPlay() íŒŒíŠ¸
```cs
// ìœ ë‹ˆí‹°
void Start() {
		nodeDiameter = nodeRadius*2;
		gridSizeX = Mathf.RoundToInt(gridWorldSize.x/nodeDiameter);
		gridSizeY = Mathf.RoundToInt(gridWorldSize.y/nodeDiameter);
		CreateGrid();
	}
```

```cpp
// ì–¸ë¦¬ì–¼
void AGrid::BeginPlay()
{
	Super::BeginPlay();

	nodeDiameter = nodeRadius * 2;
	FVector origin;
	FVector boxExtent;
	GetActorBounds(false, origin, boxExtent);

	gridWorldSizeX = boxExtent.X * 2;
	gridWorldSizeY = boxExtent.Y * 2;

	gridSizeX = FMath::RoundToInt(gridWorldSizeX / nodeDiameter);
	gridSizeY = FMath::RoundToInt(gridWorldSizeY / nodeDiameter);

	CreateGrid();

}
```
### ğŸ‘‰ğŸ» ì°¨ì´ì 
1. ë°˜ì˜¬ë¦¼ í•¨ìˆ˜
- ìœ ë‹ˆí‹°: 'Mathf.RoundToInt' í•¨ìˆ˜ ì‚¬ìš©
- ì–¸ë¦¬ì–¼: 'FMath::RoundToInt' í•¨ìˆ˜ ì‚¬ìš©

2. ë°”ìš´ë“œ ê³„ì‚°
- ìœ ë‹ˆí‹°: 'gridWorldSize'ë¥¼ ì™¸ë¶€ì—ì„œ ì§ì ‘ ì§€ì •í•´ì¤Œ
- ì–¸ë¦¬ì–¼: í•´ë‹¹ ì•¡í„°ì˜ ì½œë¦¬ì „ê³¼ ì—°ë™í•˜ì—¬ ì‚¬ìš©í• ìˆ˜ ìˆë„ë¡ í•´ë‘ì—ˆìŒ.
  - [GetActorBounds](https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/GameFramework/AActor/GetActorBounds)
  - [FMath](https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/FMath)

ìœ ë‹ˆí‹°ì—ì„œëŠ” gridWorldSizeë¥¼ ì •í•´ì¤Œìœ¼ë¡œì¨ í¬ê¸°ë¥¼ ì§€ì •í–ˆì§€ë§Œ, ë‚˜ëŠ” ì½œë¦¬ì „ê³¼ ì—°ë™í•˜ì—¬ ì‚¬ìš©í• ìˆ˜ ìˆë„ë¡ ë§Œë“¤ì–´ ë‘ì—ˆë‹¤.

## CreateGrid() íŒŒíŠ¸
```cs
// ìœ ë‹ˆí‹°
void CreateGrid() {
		grid = new Node[gridSizeX,gridSizeY];
		Vector3 worldBottomLeft = transform.position - Vector3.right * gridWorldSize.x/2 - Vector3.forward * gridWorldSize.y/2;

		for (int x = 0; x < gridSizeX; x ++) {
			for (int y = 0; y < gridSizeY; y ++) {
				Vector3 worldPoint = worldBottomLeft + Vector3.right * (x * nodeDiameter + nodeRadius) + Vector3.forward * (y * nodeDiameter + nodeRadius);
				bool walkable = !(Physics.CheckSphere(worldPoint,nodeRadius,unwalkableMask));
				grid[x,y] = new Node(walkable,worldPoint);
			}
		}
	}

```

```cpp
// ì–¸ë¦¬ì–¼
void AGrid::CreateGrid() {
	grid.SetNum(gridSizeX);
	FVector worldBottomLeft = GetActorLocation() - FVector(gridWorldSizeX / 2, gridWorldSizeY / 2, 0);

	for (int x = 0; x < gridSizeX; x++) {
		grid[x].Nodes.SetNum(gridSizeY);

		for (int y = 0; y < gridSizeY; y++) {
			FVector worldPoint = worldBottomLeft + FVector(x * nodeDiameter + nodeRadius, y * nodeDiameter + nodeRadius, 0);
			bool walkable = IsWalkable(worldPoint);
			grid[x].Nodes[y] = FNode(walkable, worldPoint);
		}
	}
}

bool AGrid::IsWalkable(const FVector& WorldPoint) {
	TArray<FOverlapResult> OverlapResults;
	FCollisionShape CollisionShape = FCollisionShape::MakeSphere(nodeRadius);

	bool bHit = GetWorld()->OverlapMultiByChannel(
		OverlapResults,
		WorldPoint,
		FQuat::Identity,
		ECollisionChannel::ECC_GameTraceChannel1,
		CollisionShape
	);

	return OverlapResults.Num() == 0;
}
```
### ğŸ‘‰ğŸ» ì°¨ì´ì 
1. ë°°ì—´ ì´ˆê¸°í™”
- ìœ ë‹ˆí‹°: new Node[gridSizeX, gridSizeY] ë¡œ ì´ˆê¸°í™”í•´ì£¼ì—ˆë‹¤.
- ì–¸ë¦¬ì–¼: TArray ë‚´ì— TArrayë¥¼ ë„£ëŠ” ê²ƒì„ í—ˆìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ì´ˆê¸°í™”í•´ì£¼ì—ˆë‹¤.

2. walkable bool ë³€ìˆ˜
- ìœ ë‹ˆí‹°: Physics.CheckSphereì™€ unwalkableMaskë¥¼ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ ë ˆì´ì–´ê°€ unwalkable ì¸ì§€ í™•ì¸í•˜ê³  ìˆë‹¤.
- ì–¸ë¦¬ì–¼: IsWalkable í•¨ìˆ˜ë¥¼ ë”°ë¡œ ì„ ì–¸í•˜ì—¬ ë‚´ë¶€ì—ì„œ Unwalkable Trace Channel(ECC_GameTraceChannel1)ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì˜€ë‹¤.  
OverlapResultsì— Unwalkable ì˜¤ë¸Œì íŠ¸ê°€ ë“¤ì–´ìˆìœ¼ë©´ false, ì•„ë‹ˆë¼ë©´ trueë¥¼ ë°˜í™˜í•œë‹¤.  
bHitì€ Blockìœ¼ë¡œ ì„¤ì •ëœ ì˜¤ë¸Œì íŠ¸ê°€ ìˆëŠ”ì§€ íŒë‹¨í•˜ëŠ” ê²ƒì´ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” ì“¸ëª¨ì—†ëŠ” ë³€ìˆ˜ì´ë‹¤.
  - [FOverlapResult](https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/Engine/FOverlapResult)
  - [OverlapMultiByChannel](https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/Engine/UWorld/OverlapMultiByChannel)

### âœ… Unwalkable Trace Channel ì°¾ê¸°
![image](https://github.com/user-attachments/assets/9d4ad045-5e71-4794-a48d-07259860555a)

DefaultEngine.iniì—ì„œ Unwalkableì„ ê²€ìƒ‰í•˜ì—¬ ì°¾ì„ ìˆ˜ ìˆë‹¤.

## NodeFromWorldPoint íŒŒíŠ¸
```cs
public Node NodeFromWorldPoint(Vector3 worldPosition) {
		float percentX = (worldPosition.x + gridWorldSize.x/2) / gridWorldSize.x;
		float percentY = (worldPosition.z + gridWorldSize.y/2) / gridWorldSize.y;
		percentX = Mathf.Clamp01(percentX);
		percentY = Mathf.Clamp01(percentY);

		int x = Mathf.RoundToInt((gridSizeX-1) * percentX);
		int y = Mathf.RoundToInt((gridSizeY-1) * percentY);
		return grid[x,y];
	}
```

```cpp
// ì–¸ë¦¬ì–¼
FNode AGrid::NodeFromWorldPoint(FVector WorldPosition) {
	float percentX = (WorldPosition.X + gridWorldSizeX / 2) / gridWorldSizeX;
	float percentY = (WorldPosition.Y + gridWorldSizeY / 2) / gridWorldSizeY;

	percentX = FMath::Clamp(percentX, 0.0f, 1.0f);
	percentY = FMath::Clamp(percentY, 0.0f, 1.0f);

	int x = FMath::RoundToInt((gridSizeX - 1) * percentX);
	int y = FMath::RoundToInt((gridSizeY - 1) * percentY);

	return grid[x].Nodes[y];
}
```

### ğŸ‘‰ğŸ» ì°¨ì´ì 
1. Clamp í•¨ìˆ˜
  - ìœ ë‹ˆí‹°: 'Mathf.Clamp01' í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ë²”ìœ„ë¥¼ 0ì—ì„œ 1ë¡œ ì œí•œí•œë‹¤.
  - ì–¸ë¦¬ì–¼: 'FMath::Clamp' í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ë²”ìœ„ë¥¼ ì œí•œí•œë‹¤.
    - [FMath::Clamp](https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/FMath/Clamp/5)

## OnDrawGizmos() / DrawDebugGrid()
```cs
void OnDrawGizmos() {
		Gizmos.DrawWireCube(transform.position,new Vector3(gridWorldSize.x,1,gridWorldSize.y));

	
		if (grid != null) {
      Node playerNode = NodeFromWorldPoint(player.position)
			foreach (Node n in grid) {
				Gizmos.color = (n.walkable)?Color.white:Color.red;
        if (playerNode == n) {
          Gizmos.color = Color.cyan;
        }
				Gizmos.DrawCube(n.worldPosition, Vector3.one * (nodeDiameter-.1f));
			}
		}
	}
```

```cpp
// ì–¸ë¦¬ì–¼
void AGrid::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	DrawDebugGrid();

}

void AGrid::DrawDebugGrid() {

	FNode PlayerNode = NodeFromWorldPoint(GetWorld()->GetFirstPlayerController()->GetPawn()->GetActorLocation());

	for (int x = 0; x < gridSizeX; x++) {
		for (int y = 0; y < gridSizeY; y++) {
			FNode Nodes = grid[x].Nodes[y];
			FColor NodesColor = Nodes.bWalkable ? FColor::Green : FColor::Red;
			if (Nodes == PlayerNode) {
				NodesColor = FColor::Blue;
			}
			DrawDebugBox(GetWorld(), Nodes.worldPosition, FVector(nodeRadius - 1, nodeRadius - 1, nodeRadius - 1), NodesColor);
		}
	}
}
```

### ğŸ‘‰ğŸ» ì°¨ì´ì 
1. OnDrawGizmosì˜ ìœ ë¬´
  - ìœ ë‹ˆí‹°: 'OnDrawGizmos()' í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ì£¼ë©´ ìë™ìœ¼ë¡œ í˜¸ì¶œëœë‹¤.
  - ì–¸ë¦¬ì–¼: DrawDebugGrid() í•¨ìˆ˜ë¥¼ ì§ì ‘ ìƒì„±í•˜ì—¬ Tick()ê³¼ ì—°ê²°í•´ì£¼ì—ˆë‹¤.

2. ê·¸ë¦¬ëŠ” ë°©ì‹
  - ìœ ë‹ˆí‹°: 'Gizmos.DrawCube()' í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œë‹¤.
  - ì–¸ë¦¬ì–¼: 'DrawDebugBox()' í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œë‹¤.

3. í”Œë ˆì´ì–´ ìœ„ì¹˜
  - ìœ ë‹ˆí‹°: ì§ì ‘ í”Œë ˆì´ì–´ë¥¼ player ë³€ìˆ˜ì— í• ë‹¹í•´ì£¼ê³  ì´ë¥¼ ì‚¬ìš©í–ˆë‹¤.
  - ì–¸ë¦¬ì–¼: ë“±ë¡ë˜ì–´ìˆëŠ” PlayerControllerì—ì„œ Pawnì„ ë½‘ì•„ì„œ ì‚¬ìš©í•œë‹¤.

# ğŸƒğŸ» ì‹¤í–‰
![image](https://github.com/user-attachments/assets/7bb8341f-29ee-45ae-98c7-12c06f1d121f)

'LiveCoding.Compile'ì„ ì³ì„œ ì»´íŒŒì¼ì„ ë¨¼ì € í•œë‹¤.  

Gridë¥¼ í™”ë©´ì— ë°°ì¹˜í•˜ê³ , BoxCollisionì˜ 'ì…°ì´í”„-ë°•ìŠ¤ í¬ê¸°' ë¥¼ ì¡°ì ˆí•˜ì—¬ Pathfinding ë²”ìœ„ë¥¼ ì§€ì •í•œë‹¤.

![image](https://github.com/user-attachments/assets/b5c645f6-26d0-4585-89a4-3bab77bdc3da)

ë²”ìœ„ê°€ ì§€ì •ëœ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. (Plane ì˜†ì˜ ì„ )

![image](https://github.com/user-attachments/assets/e8221fe1-ccbd-407c-bc85-0606973bf58d)

ì˜¬ë°”ë¥´ê²Œ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ í™•ì¸í•˜ì˜€ë‹¤.

# ğŸ“œ ì „ì²´ ì½”ë“œ
<details>
<summary>ìœ ë‹ˆí‹° (í¼ì¹˜ê¸°/ì ‘ê¸°)</summary>

```cs
// ìœ ë‹ˆí‹°
ï»¿using UnityEngine;
using System.Collections;

public class Grid : MonoBehaviour {

	public LayerMask unwalkableMask;
	public Vector2 gridWorldSize;
	public float nodeRadius;
	Node[,] grid;

	float nodeDiameter;
	int gridSizeX, gridSizeY;

	void Start() {
		nodeDiameter = nodeRadius*2;
		gridSizeX = Mathf.RoundToInt(gridWorldSize.x/nodeDiameter);
		gridSizeY = Mathf.RoundToInt(gridWorldSize.y/nodeDiameter);
		CreateGrid();
	}

	void CreateGrid() {
		grid = new Node[gridSizeX,gridSizeY];
		Vector3 worldBottomLeft = transform.position - Vector3.right * gridWorldSize.x/2 - Vector3.forward * gridWorldSize.y/2;

		for (int x = 0; x < gridSizeX; x ++) {
			for (int y = 0; y < gridSizeY; y ++) {
				Vector3 worldPoint = worldBottomLeft + Vector3.right * (x * nodeDiameter + nodeRadius) + Vector3.forward * (y * nodeDiameter + nodeRadius);
				bool walkable = !(Physics.CheckSphere(worldPoint,nodeRadius,unwalkableMask));
				grid[x,y] = new Node(walkable,worldPoint);
			}
		}
	}

	public Node NodeFromWorldPoint(Vector3 worldPosition) {
		float percentX = (worldPosition.x + gridWorldSize.x/2) / gridWorldSize.x;
		float percentY = (worldPosition.z + gridWorldSize.y/2) / gridWorldSize.y;
		percentX = Mathf.Clamp01(percentX);
		percentY = Mathf.Clamp01(percentY);

		int x = Mathf.RoundToInt((gridSizeX-1) * percentX);
		int y = Mathf.RoundToInt((gridSizeY-1) * percentY);
		return grid[x,y];
	}

	void OnDrawGizmos() {
		Gizmos.DrawWireCube(transform.position,new Vector3(gridWorldSize.x,1,gridWorldSize.y));
	
		if (grid != null) {
      Node playerNode = NodeFromWorldPoint(player.position)
			foreach (Node n in grid) {
				Gizmos.color = (n.walkable)?Color.white:Color.red;
        if (playerNode == n) {
          Gizmos.color = Color.cyan;
        }
				Gizmos.DrawCube(n.worldPosition, Vector3.one * (nodeDiameter-.1f));
			}
		}
	}

public class Node {
	
	public bool walkable;
	public Vector3 worldPosition;
	
	public Node(bool _walkable, Vector3 _worldPos) {
		walkable = _walkable;
		worldPosition = _worldPos;
	}
}
```

</details>

<details>
<summary>ì–¸ë¦¬ì–¼ (í¼ì¹˜ê¸°/ì ‘ê¸°)</summary>

```cpp
// ì–¸ë¦¬ì–¼ cpp íŒŒì¼

#include "Engine/World.h"
#include "Engine/OverlapResult.h"
#include "Grid.h"
#include "DrawDebugHelpers.h"
#include "Components/PrimitiveComponent.h"
#include "Components/BoxComponent.h"

// Sets default values
AGrid::AGrid()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	BoxCollision = CreateDefaultSubobject<UBoxComponent>(TEXT("BoxCollision"));
	SetRootComponent(BoxCollision);

}

// Called when the game starts or when spawned
void AGrid::BeginPlay()
{
	Super::BeginPlay();

	nodeDiameter = nodeRadius * 2;
	FVector origin;
	FVector boxExtent;
	GetActorBounds(false, origin, boxExtent);

	gridWorldSizeX = boxExtent.X * 2;
	gridWorldSizeY = boxExtent.Y * 2;

	gridSizeX = FMath::RoundToInt(gridWorldSizeX / nodeDiameter);
	gridSizeY = FMath::RoundToInt(gridWorldSizeY / nodeDiameter);

	CreateGrid();

}

// Called every frame
void AGrid::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	DrawDebugGrid();

}

void AGrid::CreateGrid() {
	grid.SetNum(gridSizeX);
	FVector worldBottomLeft = GetActorLocation() - FVector(gridWorldSizeX / 2, gridWorldSizeY / 2, 0);

	for (int x = 0; x < gridSizeX; x++) {
		grid[x].Nodes.SetNum(gridSizeY);

		for (int y = 0; y < gridSizeY; y++) {
			FVector worldPoint = worldBottomLeft + FVector(x * nodeDiameter + nodeRadius, y * nodeDiameter + nodeRadius, 0);
			bool walkable = IsWalkable(worldPoint);
			grid[x].Nodes[y] = FNode(walkable, worldPoint);
		}
	}
}

FNode AGrid::NodeFromWorldPoint(FVector WorldPosition) {
	float percentX = (WorldPosition.X + gridWorldSizeX / 2) / gridWorldSizeX;
	float percentY = (WorldPosition.Y + gridWorldSizeY / 2) / gridWorldSizeY;

	percentX = FMath::Clamp(percentX, 0.0f, 1.0f);
	percentY = FMath::Clamp(percentY, 0.0f, 1.0f);

	int x = FMath::RoundToInt((gridSizeX - 1) * percentX);
	int y = FMath::RoundToInt((gridSizeY - 1) * percentY);

	return grid[x].Nodes[y];
}

bool AGrid::IsWalkable(const FVector& WorldPoint) {
	TArray<FOverlapResult> OverlapResults;
	FCollisionShape CollisionShape = FCollisionShape::MakeSphere(nodeRadius);

	bool bHit = GetWorld()->OverlapMultiByChannel(
		OverlapResults,
		WorldPoint,
		FQuat::Identity,
		ECollisionChannel::ECC_GameTraceChannel1,
		CollisionShape
	);

	return OverlapResults.Num() == 0;
}

void AGrid::DrawDebugGrid() {

	FNode PlayerNode = NodeFromWorldPoint(GetWorld()->GetFirstPlayerController()->GetPawn()->GetActorLocation());

	for (int x = 0; x < gridSizeX; x++) {
		for (int y = 0; y < gridSizeY; y++) {
			FNode Nodes = grid[x].Nodes[y];
			FColor NodesColor = Nodes.bWalkable ? FColor::Green : FColor::Red;
			if (Nodes == PlayerNode) {
				NodesColor = FColor::Blue;
			}
			DrawDebugBox(GetWorld(), Nodes.worldPosition, FVector(nodeRadius - 1, nodeRadius - 1, nodeRadius - 1), NodesColor);
		}
	}
}

```

</details>